/* autogenerated by Processing revision 1289 on 2023-01-27 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class KMeanUltimate extends PApplet {

ArrayList<Point> points;
int k = 5;
int n = 1000;
int num[] = {-1, 1};
Centroid centroids[] = new Centroid[k];
ArrayList<Point> centers;

public void setup() {
  /* size commented out by preprocessor */;
  reset();
}

public void drawPoints() {
  for (Point p: points) {
    p.display();
  }
  for (Centroid c: centroids) {
    c.display();
  }
  for (Point c: centers) {
    c.display();
  }
}

public float randomize(float n) {
  return n + pow(-1, PApplet.parseInt(random(2))) * random(random(0.2f));
}

public void reset() {
  points = new ArrayList<>();
  centers = new ArrayList<>();
  for (int i = 0; i < k; i++) {
    float _x = random(1), _y = random(1);
    centers.add(new Point(_x, _y, color(0, 0, 255)));
    Centroid cc = new Centroid();
    //cc.pos = new PVector(_x, _y);
    centroids[i] = cc;
    int c = color((int)random(255), (int)random(255), (int)random(255));
    for (int j = 0; j < n; j++) {
      float x = randomize(_x), y = randomize(_y);
      Point p = new Point(x, y, c);
      points.add(p);
    }
    
  }
}

public void fitCentroids() {
  for (Centroid c: centroids) {
    c.neighbours = new ArrayList<>();
  }
  
  for (Point p: points) {
    int min_i = 0;
    float min_dist = 10e6f;
    for (int i = 0; i < k; i++) {
      float d = p.pos.dist(centroids[i].pos);
      if (min_dist > d) {
        min_dist = d;
        min_i = i;
      }
    }
    centroids[min_i].addNeighbour(p);
  }
  
  for (Centroid c: centroids) {
    c.update();
  }
}

public void resetCentroids() {
  for (int i = 0; i < k; i++){
    centroids[i] = new Centroid();
  }
}

public void keyPressed() {
  if (keyCode == UP) {
    println("Resetting Centroid Positions");
    resetCentroids();
  } else if (keyCode == DOWN) {
    println("Resetting Setup");
    reset();
  }
}

public void mousePressed() {
  fitCentroids();
}

public void draw() {
  background(100);
  drawPoints();
}
public class Centroid {
  PVector pos;
  float radius;
  ArrayList<Point> neighbours;
  Centroid() {
    pos = new PVector(random(1), random(1));
    radius = 0;
    neighbours = new ArrayList<>();
  }
  
  public void update() {
    setPos();
    setRadius();
  }
  
  public void setPos() {
    this.pos = new PVector(0,0);
    if(this.neighbours.size() > 0) {
      for (Point p : this.neighbours) {
        this.pos.add(p.pos);
      }
      this.pos.div(this.neighbours.size());
    } else {
      this.pos = new PVector(0.5f, 0.5f);
    }
  }
  
  public void setRadius() {
    this.radius = 0;
    for (Point p : this.neighbours) {
      float r = p.pos.dist(this.pos);
      this.radius = this.radius < r ? r : this.radius;
    }
  }
  
  public void connectPoints() {
    fill(0, 255, 0);
    stroke(0, 255, 0);
    for(Point p: this.neighbours){
      line(p.pos.x*width, p.pos.y*height, this.pos.x*width, this.pos.y*height);
    }
  }
  
  public void addNeighbour(Point p) {
    int i = 0;
    for (; i < this.neighbours.size(); i++) {
      if (calcAngle(p.pos) < calcAngle(this.neighbours.get(i).pos)) {
        break;
      }
    }
    this.neighbours.add(i, p);
  }
  
  public float calcAngle(PVector p) {
    return degrees(atan2( (this.pos.y - p.y), (this.pos.x - p.x) ));
  }
  
  public void display() {
    fill(0, 220, 35, 50);
    stroke(0, 255, 255);
    beginShape();
    for(Point p: this.neighbours) {
      curveVertex(p.pos.x, p.pos.y);
    }
    endShape();
    
    //for (int i = 0; i < this.neighbours.size() - 3; i++){
    //  curve(this.neighbours.get(i).x, this.neighbours.get(i).y, this.neighbours.get(i+1).x, this.neighbours.get(i+1).y, this.neighbours.get(i+2).x, this.neighbours.get(i+2).y, this.neighbours.get(i+3).x, this.neighbours.get(i+3).y);
    //}
    
    circle(this.pos.x * width, this.pos.y * height, 2*this.radius*width);
    connectPoints();
    fill(0);
    circle(this.pos.x * width, this.pos.y * height, 10);
  }
  
  
  //connectPoints();
}
public class Point {
  PVector pos;
  int c;
  Point (float x, float y, int co) {
    pos = new PVector(x, y);
    c = co;
  }
  
  public void display () {
    fill(this.c);
    stroke(0);
    circle(this.pos.x * width, this.pos.y * height, 10);
  }
}
public class Points {
  PVector pos;
  int c;
  Points (float x, float y, int co) {
    pos = new PVector(x, y);
    c = co;
  }
  
  public void display () {
    fill(this.c);
    stroke(0);
    circle(this.pos.x * width, this.pos.y * height, 10);
  }
}


  public void settings() { size(800, 800); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "KMeanUltimate" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
